participant "client" as Client
participant "server" as Server

bottomparticipants

fontfamily arial

entryspacing 1.0
note over Client:client:\n• supports mTLS authentication with X.509 certificates\n• uses a self-signed or CA-signed certificate with a certificate extension containing a custom OID and\n   ASN1:UTF8String value that serves as a global client identifier in respect of the service it represents,\n   e.g., 1.2.3.4.5.6.7.8=ASN1:UTF8String:client._mhs._grip.foo.com\n• the client's public key fingerprint is published on the client domain using DNS TXT record,\n   e.g., client._mhs._grip.foo.com IN TXT  "v=grip1; h=sha256; f=d2abde240d7cd3ee6b ... e971"
note over Server:server:\n• supports mTLS authentication with X.509 certificates\n• uses a CA-signed certificate with an appropriate Subject Alternative Name (SAN)\n• uses a DNS SRV record to specify a host and port of the server, while identifies the respective service,\n   e.g., _mhs._tcp.bar.com IN SRV 100 1 2525 mhs-server.bar.com\n• uses the information in the assertion to identify the requesting party (user)
Client->Client:1. The client generates a security token — a signed (using the client's private key) DNS-bound assertion\n      in JWT format with these claims: {iat, iss, aud, sub, jwks, dlgr{sub}, token}\n    • iat: the issued-at timestamp of the token\n    • iss: identifies who issues the token — CN from public client's certificate, e.g., foo.com\n    • aud: identifies the target service by the DNS SRV record, e.g., _mhs._tcp.bar.com\n    • sub: identifies the requesting party by email address, e.g., alice.baz.com\n    • dlgr{sub}: delegator — an authorized client A (e.g., client._mhs._grip.baz.com) that authorizes\n       client B (e.g, client._mhs._grip.foo.com) to act on behalf of the requesting party (e.g., alice.baz.com)\n    • jwks: holds the client's certificate public key in the JWK Set format (alternatively provide JWK Set by\n       URI using jwks_uri claim)\n    • token (optional): a tokenized digital resource (message, blob, security token from the previous hop, ...)\n
Client->Server:2. Send an HTTPS request to the server with the security token using mTLS
Server->Server:3. authorization decision\n    • the client is authenticated via the DNS using the TXT record and\n       the custom OID value from the public client's certificate\n    • verify the security token signature\n    • validate proof-of-possession\n    • verify the 'aud' claim\n    • validate the 'sub' claim, the domain part of the requesting party\n       email address and the domain part of the dlgr{sub} must match\n    • (optional) validate the tokenized digital resource
Server->Client:4. Return the HTTP response, typically with 200, 201 status code
